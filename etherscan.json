{"language":"Solidity","sources":{"src/Coins.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.29;\n\nerror OnlyExternal();\nerror Unauthorized();\nerror InvalidMetadata();\nerror DeploymentFailed();\n\n/// @title Coins\n/// @notice Singleton for ERC6909 & ERC20s\n/// @author z0r0z & 0xc0de4c0ffee & kobuta23\ncontract Coins {\n    event MetadataSet(uint256 indexed);\n    event OwnershipTransferred(uint256 indexed);\n\n    event OperatorSet(address indexed, address indexed, bool);\n    event Approval(address indexed, address indexed, uint256 indexed, uint256);\n    event Transfer(address, address indexed, address indexed, uint256 indexed, uint256);\n\n    Token immutable implementation = new Token{salt: keccak256(\"\")}();\n\n    mapping(uint256 id => Metadata) _metadata;\n\n    mapping(uint256 id => uint256) public totalSupply;\n    mapping(uint256 id => address owner) public ownerOf;\n\n    mapping(address owner => mapping(uint256 id => uint256)) public balanceOf;\n    mapping(address owner => mapping(address operator => bool)) public isOperator;\n    mapping(address owner => mapping(address spender => mapping(uint256 id => uint256))) public\n        allowance;\n\n    modifier onlyOwnerOf(uint256 id) {\n        require(msg.sender == ownerOf[id], Unauthorized());\n        _;\n    }\n\n    constructor() payable {}\n\n    // METADATA\n\n    struct Metadata {\n        string name;\n        string symbol;\n        string tokenURI;\n    }\n\n    function name(uint256 id) public view returns (string memory) {\n        Metadata storage meta = _metadata[id];\n        return bytes(meta.tokenURI).length != 0 ? meta.name : Token(address(uint160(id))).name();\n    }\n\n    function symbol(uint256 id) public view returns (string memory) {\n        Metadata storage meta = _metadata[id];\n        return bytes(meta.tokenURI).length != 0 ? meta.symbol : Token(address(uint160(id))).symbol();\n    }\n\n    function decimals(uint256 id) public view returns (uint8) {\n        return bytes(_metadata[id].tokenURI).length != 0\n            ? 18\n            : uint8(Token(address(uint160(id))).decimals());\n    }\n\n    function tokenURI(uint256 id) public view returns (string memory) {\n        return _metadata[id].tokenURI;\n    }\n\n    // CREATION\n\n    function create(\n        string calldata _name,\n        string calldata _symbol,\n        string calldata _tokenURI,\n        address owner,\n        uint256 supply\n    ) public {\n        require(bytes(_tokenURI).length != 0, InvalidMetadata());\n        uint256 id;\n        Token _implementation = implementation;\n        bytes32 salt = keccak256(abi.encodePacked(_name, address(this), _symbol));\n        assembly (\"memory-safe\") {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, _implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            id := create2(0, 0x0c, 0x35, salt)\n            if iszero(id) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0)\n        }\n        _metadata[id] = Metadata(_name, _symbol, _tokenURI);\n        emit Transfer(\n            msg.sender,\n            address(0),\n            ownerOf[id] = owner,\n            id,\n            balanceOf[owner][id] = totalSupply[id] = supply\n        );\n    }\n\n    // WRAPPING\n\n    function wrap(Token token, uint256 amount) public {\n        uint256 id = uint160(address(token));\n        require(bytes(_metadata[id].tokenURI).length == 0, OnlyExternal());\n        token.transferFrom(msg.sender, address(this), amount);\n        _mint(msg.sender, id, amount);\n    }\n\n    function unwrap(Token token, uint256 amount) public {\n        _burn(msg.sender, uint256(uint160(address(token))), amount);\n        token.transfer(msg.sender, amount);\n    }\n\n    // MINT/BURN\n\n    function mint(address to, uint256 id, uint256 amount) public onlyOwnerOf(id) {\n        _mint(to, id, amount);\n    }\n\n    function burn(uint256 id, uint256 amount) public {\n        _burn(msg.sender, id, amount);\n    }\n\n    // GOVERNANCE\n\n    function setMetadata(uint256 id, string calldata _tokenURI) public onlyOwnerOf(id) {\n        require(bytes(_tokenURI).length != 0, InvalidMetadata());\n        _metadata[id].tokenURI = _tokenURI;\n        emit MetadataSet(id);\n    }\n\n    function transferOwnership(uint256 id, address newOwner) public onlyOwnerOf(id) {\n        ownerOf[id] = newOwner;\n        emit OwnershipTransferred(id);\n    }\n\n    // ERC6909\n\n    function transfer(address to, uint256 id, uint256 amount) public returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n        unchecked {\n            balanceOf[to][id] += amount;\n        }\n        emit Transfer(msg.sender, msg.sender, to, id, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 id, uint256 amount)\n        public\n        returns (bool)\n    {\n        if (msg.sender != address(uint160(id))) {\n            if (!isOperator[from][msg.sender]) {\n                if (allowance[from][msg.sender][id] != type(uint256).max) {\n                    allowance[from][msg.sender][id] -= amount;\n                }\n            }\n        }\n        balanceOf[from][id] -= amount;\n        unchecked {\n            balanceOf[to][id] += amount;\n        }\n        emit Transfer(msg.sender, from, to, id, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 id, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n        emit Approval(msg.sender, spender, id, amount);\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    // ERC20 APPROVAL\n\n    function setAllowance(address owner, address spender, uint256 id, uint256 amount)\n        public\n        payable\n        returns (bool)\n    {\n        require(msg.sender == address(uint160(id)), Unauthorized());\n        allowance[owner][spender][id] = amount;\n        emit Approval(owner, spender, id, amount);\n        return true;\n    }\n\n    // ERC165\n\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165\n            || interfaceId == 0x0f632fb3; // ERC6909\n    }\n\n    // INTERNAL MINT/BURN\n\n    function _mint(address to, uint256 id, uint256 amount) internal {\n        totalSupply[id] += amount;\n        unchecked {\n            balanceOf[to][id] += amount;\n        }\n        emit Transfer(msg.sender, address(0), to, id, amount);\n    }\n\n    function _burn(address from, uint256 id, uint256 amount) internal {\n        balanceOf[from][id] -= amount;\n        unchecked {\n            totalSupply[id] -= amount;\n        }\n        emit Transfer(msg.sender, from, address(0), id, amount);\n    }\n}\n\ncontract Token {\n    event Approval(address indexed, address indexed, uint256);\n    event Transfer(address indexed, address indexed, uint256);\n\n    uint256 public constant decimals = 18;\n    address immutable coins = msg.sender;\n\n    constructor() payable {}\n\n    function name() public view returns (string memory) {\n        return Coins(coins).name(uint160(address(this)));\n    }\n\n    function symbol() public view returns (string memory) {\n        return Coins(coins).symbol(uint160(address(this)));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return Coins(coins).totalSupply(uint160(address(this)));\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return Coins(coins).balanceOf(owner, uint160(address(this)));\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        if (Coins(coins).isOperator(owner, spender)) return type(uint256).max;\n        return Coins(coins).allowance(owner, spender, uint160(address(this)));\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        emit Approval(msg.sender, spender, amount);\n        return Coins(coins).setAllowance(msg.sender, spender, uint160(address(this)), amount);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        emit Transfer(msg.sender, to, amount);\n        return Coins(coins).transferFrom(msg.sender, to, uint160(address(this)), amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        require(allowance(from, msg.sender) >= amount, Unauthorized());\n        emit Transfer(from, to, amount);\n        return Coins(coins).transferFrom(from, to, uint160(address(this)), amount);\n    }\n}\n"}},"settings":{"remappings":["@solady/=lib/solady/","@forge/=lib/forge-std/src/","forge-std/=lib/forge-std/src/","solady/=lib/solady/src/"],"optimizer":{"enabled":true,"runs":9999999},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
